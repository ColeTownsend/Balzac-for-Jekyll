

<!doctype html>
<html lang="en" prefix="og: http://ogp.me/ns#">
<meta charset="utf-8">
<title>Elixir Concurrent Programming. &#8211; Bruno Ripa</title>
<meta name="description" content="GenServer module for concurrent programming in Elixir">
<meta name="keywords" content="">

<!-- DSLs for various open graph languages -->
<meta property="og:locale" content="en_EN">
<meta property="og:title" content="Elixir Concurrent Programming. &#8211; Bruno Ripa">
<meta property="og:description" content="GenServer module for concurrent programming in Elixir">
<meta property="og:url" content="/articles/genserver">
<meta property="og:site_name" content="Bruno Ripa">

<meta property="og:image" content="bigdata.jpeg">





<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Bruno Ripa Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Type -->
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Crimson+Text:400,400italic,700,700italic" rel='stylesheet' type='text/css' />
<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="/assets/css/entypo.css" media="all">

<!-- In order to use Calendas Plus, you must first purchase it. Then, create a font-face package using FontSquirrel.
<link rel='stylesheet' href='/assets/cal.css' media='all' />
-->



<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/i.css">

<!-- Fresh Squeezed jQuery -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script>

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>


<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="/favicon.ico">

<div id="bump">
  <body class="">
    <header class="site-header">
      <div class="wrap">
        <hgroup>
          <h1><a href="/">Bruno Ripa</a></h1>
        </hgroup>
        <a href="#nav" class="menu"><span class='icons'>☰</span></a>
        <nav role="navigation">
          <ul>
            <li>
              <a href="/" title="Bruno Ripa">Home</a>
            </li>
            
            
                <li><a href="/about" >About</a></li>
            
                <li><a href="https://twitter.com/brunoripa"  target="_blank">Twitter</a></li>
            
                <li><a href="https://linkedin.com/in/brunoripa"  target="_blank">LinkedIn</a></li>
            
                <li><a href="https://github.com/brunoripa"  target="_blank">Github</a></li>
            

          </ul>
        </nav>
      </div>
    </header>


<section class="article">

  <div class="overlay"></div>
  <div class="featured-image" style="background-image: url(/images/bigdata.jpeg)"></div>


      <article class="wrap post">
        <header class="post-header">
          <hgroup>
            <h1>Elixir Concurrent Programming.</h1>
            <p class="intro">GenServer module for concurrent programming in Elixir</p>

          </hgroup>
        </header>

        <h2 id="introduction">Introduction</h2>

<p>In <code>Elixir</code> if you need to write concurrent code, the <code>GenServer</code> module offers you lots of nice functions to handle the boilerplate it takes.</p>

<p>Let’s imagine we have a module called <code>Concurrent</code> and you want it to be run into a detached process; all it takes is to wrap it using the <code>GenServer</code> module: it exposes a bunch of special functions that help you define the way your concurrent module must work.</p>

<p>Let’s start with a very simple example.</p>

<noscript><pre>400: Invalid request
</pre></noscript>
<script src="https://gist.github.com/224cb9869e83853ddfa9748658a33b31.js"> </script>

<p>The <code>start_link</code> function is used to launch a <code>GenServer</code> process.</p>

<p>To try it, just type <code>iex -S mix</code> and type <code>Concurrent.start_link</code>; here’s the output you should be seeing:</p>

<pre><code>iex(5)&gt; Concurrent.start_link
  {:ok, #PID&lt;0.164.0&gt;}
</code></pre>

<p>As you can see, a tuple is returned: the <code>:ok</code> atom and the process id for the process.</p>

<p><strong>Note</strong>: the special <code>__MODULE__</code> variable is used to automatically provide the module name to the <code>start_link</code> function, which is supposed to receive it. Also, the second argument, the empty list [], is the initial state of the process, which in this example is empty.</p>

<p>If, by any chance, you need to make some stuff when the process starts, you can implement the <code>init</code> function (if you don’t provide your own implementation, a warning will be shown and a default implementation will be injected by the compiler).</p>

<noscript><pre>400: Invalid request
</pre></noscript>
<script src="https://gist.github.com/6f27e8d61dd67aa8d274fe660998e9c1.js"> </script>

<p>Execute this (don’t forget to type recompile if you’re still in the old <code>iex</code> session) and you will see:</p>

<pre><code>21:25:33.310 [info] Starting Elixir.Concurrent
  {:ok, #PID&lt;0.177.0&gt;}
</code></pre>

<p>So now you can also see the log message we injected in our init implementation. Please also note that you must return the tuple {:ok, initial_data} when you provide your function implementation.
On the other side, the initial_data is whatever is passed to the start_link function.</p>

<h3 id="what-about-the-state-">What about the state ?</h3>

<p>I have previously mentioned that the <code>GenServer</code> module gives you the chance to store the state of the process. Let’s understand how.</p>

<p>We have seen that whatever is passed to <code>start_link</code> is injected into the <code>initial_data</code>, which represents the inital state of the module. So, we can retrieve the state of the process by using the call function of the <code>GenServer</code> module:</p>

<pre><code>GenServer.call(pid, {:get_state})
</code></pre>

<p>Anytime the <code>GenServer.call</code> function is invoked the compiler looks for any existing implementation of the <code>handle_call</code> function, selecting the right one by applying pattern matching using the second argument provided. For example, assuming the following implementation is provided:</p>

<noscript><pre>400: Invalid request
</pre></noscript>
<script src="https://gist.github.com/cc0e3f614e0d020820c264677536f7f9.js"> </script>

<p>By typing in the <code>iex</code> session:</p>

<pre><code>GenServer.call(pid, {:get_state})
</code></pre>

<p>will make you obtain:</p>

<pre><code>iex(4)&gt; GenServer.call(pid, {:get_state})
  []
</code></pre>

<p>The <code>handle_call</code> function takes 3 arguments:</p>

<ol>
  <li>the identifier and the arguments for the function</li>
  <li>a reference to the caller</li>
  <li>the current state of the process</li>
</ol>

<p>So this is the signature that your function must have. On the other side, the return value is always a tuple with the <code>:reply</code> atom as first argument, indicating that the function is actually returning something; the second one is the response value, and the last one is the new state that this process will hold (as you can understand, they are the same in our implementation since we are not changing anything here).</p>

<p>Note: the <code>handle_call</code> function is synchronous, meaning that it will be blocking the code execution until the response is ready and returned.</p>

<p>Of course, we might create an helper function to retrieve the state of the process:</p>

<noscript><pre>400: Invalid request
</pre></noscript>
<script src="https://gist.github.com/bc023a938bd440e89e010295d7f18d2f.js"> </script>

<h3 id="updating-the-state-of-a-process">Updating the state of a process</h3>

<p>If i have not lost you so far, it might be pretty easy to understand that changing the state of a process can be a very easy task. For example:</p>

<noscript><pre>400: Invalid request
</pre></noscript>
<script src="https://gist.github.com/b2db8c0563ecc722e2878a5653ccd2c7.js"> </script>

<p>which will give us:</p>

<pre><code>iex(7)&gt; {:ok, pid} = Concurrent.start_link
  22:46:50.703 [info] Starting Elixir.Concurrent
  {:ok, #PID&lt;0.469.0&gt;}
  iex(8)&gt; Concurrent.get_state(pid)
  []
  iex(9)&gt; Concurrent.set_state(pid, "test")
  %{state: "test"}
</code></pre>

<p><strong>Note</strong>: this is of course a pretty useless state management logic, consider it just a placeholder for something worth showing :D</p>

<h3 id="interprocess-communication">Interprocess communication</h3>

<p>In order to make possible for processes to communicate <code>GenServer</code> exposes, among the others, 3 functions:</p>

<ul>
  <li>handle_call</li>
  <li>handle_cast</li>
  <li>handle_info</li>
</ul>

<p>All of them access the current state of the process, and all of them return it.</p>

<p>The one that differs the most from the others is the <code>handle_call</code> one, which receives the from parameter and returns a tuple with 3 elements, the second one being the response value. Do not confuse this with the last argument, the new state, which is used to update the current state of the process.</p>

<p>We have already seen how to use the <code>handle_call</code> one, which, i remember, is synchronous. <code>handle_cast</code>, instead, is triggered by the <code>GenServer.cast</code> call, and is the one to be used if you do not need immediate response and can afford to go asynchronous.</p>

<pre><code>GenServer.cast(pid, {:something_to_cast})
</code></pre>

<p>This method will only return the <code>:ok</code> atom.</p>

<p>About <code>GenServer.handle_info</code>, we must observe that no <code>GenServer.info</code> will exist, and can be used to receive messages from any <code>Elixir</code> process except <code>GenServer</code>. For example, the one to send a message to our <code>GenServer</code> process can be the standard <code>Elixir</code> Process module, by using the send function. Like <code>handle_cast</code> it always returns the <code>:ok</code> atom.</p>

<h3 id="an-example-of-synchronous-vs-asynchronous-scenario">An example of synchronous vs asynchronous scenario</h3>

<p>Imagine we have a payment system, where clients send a payload that describes the item to purchase; we can have two types of implementation:</p>

<ul>
  <li>a <em>synchronous</em> one: the client must wait for a response from the process, and so the user</li>
  <li>an <em>asynchronous</em> one: the client gets detached after the payload delivery and the user can keep on using the application</li>
</ul>

<p>Of course, the second implementation requires other features, like the ability to notify a client about a successful (or not) purchase; it is by far the more convenient for a good user experience, but it’s not that unusual to find synchronous implementations around.</p>

<p>In this scenario we will be having the following code:</p>

<noscript><pre>400: Invalid request
</pre></noscript>
<script src="https://gist.github.com/c387737db88ec633f56983719d431dd1.js"> </script>

<p>Also, we have added a new module, to better outline concepts and responsibilities:</p>

<noscript><pre>400: Invalid request
</pre></noscript>
<script src="https://gist.github.com/b0b53724bf55d5c5cb5552127efd12cd.js"> </script>

<p>After recompiling the code in the <code>iex</code> session, we will see:</p>

<pre><code>iex(20)&gt; {:ok, pid} = Concurrent.start_link
  10:08:51.953 [info] Starting Elixir.Concurrent
  {:ok, #PID}
  iex(21)&gt; PaymentProcessor.process_payment("payload")
  :ok
  10:08:53.233 [info] Starting Elixir.Concurrent
  10:08:53.233 [info] Elixir.Concurrent: done
  10:08:53.233 [info] Elixir.PaymentProcessor: payment processed
</code></pre>

<p>So we start the <code>Concurrent</code> process, that will be handling payments, and use the <code>PaymentProcess</code> one to trigger the process of a payment.</p>

<p>If we want to go asynchronous, we must slightly modify our code. We need a function to handle the <code>GenServer.cast</code> call:</p>

<noscript><pre>400: Invalid request
</pre></noscript>
<script src="https://gist.github.com/f9ec7978cea140ec808b4f95ead256dd.js"> </script>

<p>As well as a helper function in the <code>Concurrent</code> module:</p>

<noscript><pre>400: Invalid request
</pre></noscript>
<script src="https://gist.github.com/9c81c6b36401ec3f295ede692257a3cf.js"> </script>

<p>Last, but not least, to have consistent names, we add the following function to the <code>PaymentProcessor</code> module:</p>

<noscript><pre>400: Invalid request
</pre></noscript>
<script src="https://gist.github.com/bc6f45684b8defd1941f577a6ea95269.js"> </script>

<p>Recompiling the code and executing again:</p>

<pre><code>iex(48)&gt; {:ok, pid} = Concurrent.start_link
  10:54:29.690 [info] Starting Elixir.Concurrent
  {:ok, #PID}
  iex(49)&gt; PaymentProcessor.submit_payment("test")
  10:54:30.475 [info] Starting Elixir.Concurrent
  10:54:30.475 [info] Elixir.Concurrent: done
  10:54:30.475 [info] Elixir.PaymentProcessor: payment processed. Process detached.
  :ok
  iex(50)&gt;
  10:54:33.476 [info] Payload test has been processed.
</code></pre>

<p>As you can see, the client is totally detached from the payment process, and after 3 seconds (because of the <code>:timer.sleep(3000)</code> command) the <code>Payload test has been processed</code> pops up.</p>

<p>So, we made hopefully clear that if you have clear in mind what problem you are resoliving, if it needs concurrent code execution, <code>GenServer</code> module can be a great help.</p>

<p>The next reasonable question is: how can I be sure that a given process does not crash ? The answer is <strong>Supervisor</strong>.</p>

<h2 id="the-supervisor-module">The Supervisor module</h2>

<p>The <code>Supervisor</code> module is able to control a <code>GenServer</code> process and respawn it if crashes, according to some specific policies.</p>

<p>Let’s jump straight on the code:</p>

<noscript><pre>400: Invalid request
</pre></noscript>
<script src="https://gist.github.com/6287a85c6e979c113127974133c759cb.js"> </script>

<p>If you, as always, test it in the <code>iex</code> session, you will see:</p>

<pre><code>iex(5)&gt; ConcurrentSupervisor.start_link
  09:55:47.943 [info] Starting Elixir.Concurrent
  {:ok, #PID&lt;0.142.0&gt;}
</code></pre>

<p>So basically we are having back the pid of the <code>Supervisor</code> process, and we can see the log of the <code>Concurrent</code> process that is started.</p>

<p>As you can see, the children list is made by the modules we want to run, wrapped in a <code>worker</code> function, which represents a sort of template; it receives the module to wrap and the list of options to pass to it. Pay attention here: what you pass to the worker is used as argument of the module <code>start_link</code> function, where you have to correctly handle them before injecting in the <code>GenServer.start_link</code> call in your module.</p>

<p>Basically, if you pass values there, the signature of your module <code>start_link</code> must accept them.</p>

<p>Once the <code>Supervisor</code> starts and launches the workers, it calls, by default, the <code>start_link</code> method of the module it wraps.</p>

<h3 id="supervisor-strategies">Supervisor strategies</h3>

<p>In the <code>supervise</code> command we must pass a strategy type. Possible values are:</p>

<ul>
  <li><code>:one_for_one</code>: if any of the worker crashes, it gets restarted</li>
  <li><code>:one_for_all</code>: if any of the worker crashes, all of them are restarted</li>
  <li><code>:rest_for_one</code>: if one of the worker crashes, only the ones defined right below it (in the children list) get restarted</li>
  <li><code>:simple_one_for_one</code>: this is slightly different from other strategies; we’ll see this laters.</li>
</ul>

<p>For example, imagine that we have a children like the following:</p>

<pre><code>children = [
  worker(ConcurrentA, []),
  worker(ConcurrentB, []),
  worker(ConcurrentC, [])
]
</code></pre>

<p>with 3 existing modules, <code>:one_for_one</code> would cause that any of the workers crashing will be automatically restarted, always; <code>:one_for_all</code> means that if one of the workers crashes, all of them will be restarted; <code>:rest_for_one</code> means that if <code>ConcurrentB</code> crashes, it and <code>ConcurrentC</code> will be restarted.</p>

<h3 id="a-different-strategy-simple_on_for_one">A different strategy: :simple_on_for_one</h3>

<p>If you create a <code>Supervisor</code> that uses such strategy and you try to start it you will see that no workers are launched; it’s because this strategy pretends explicit and manual starting of the workers, by using <code>Supervisor.start_child</code>; this means that you have the flexibility to spawn multiple occurrences of the same process. Basically, the whole idea of this strategy is that you might need an undefined number of processes, spawning more of them, for example, due to some specific demand or needs. The lifecycle of the workers of a Supervisor so defined must explicitly be controlled, as already told, by using some Supervisor functions like <code>stat_child</code> and <code>terminate_child</code>.</p>

<h3 id="the-restart-option">The restart option</h3>

<p>The worker function takes an optional restart argument that can define the restart policies for the process. Possible values are:</p>

<ul>
  <li><code>:permanent</code>: the crashing process will always be restarted. This option is default for all the strategies except the :simple_rest_for_one one.</li>
  <li><code>:transient</code>: the process is restarted only in case of cerash. Nothing will be done if the process will be termined by user command, for example. This option is default for :simple_rest_for_one.</li>
  <li><code>:temporary</code>: a terminating process will never be restarted.</li>
</ul>

<p>It’s not unusual that an <code>Elixir</code> application spawns a big number of processes, so dealing with pids might be tricky and error prone. Since version 1.4, the <code>Registry</code> module is there to help us giving the chance to play with processes and using them by names and not pids. I will cover the <code>Registry</code> in a separated article in the near future.</p>


        <a class="share" href="https://twitter.com/intent/tweet?text=&quot;Elixir Concurrent Programming.&quot;%20https://brunoripa.com/articles/genserver%20via%20&#64;brunoripa" data-dnt="true">Share</a>
        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

      </article>
    </section>
</div>

<div class="push"></div>
  <footer>
    <aside class="wrap">
      <ol class="prev-posts">
        <p class="list-title">Recent Posts</p>
         <!-- for1 -->
            <li>
              <span class="recent-title"><a href="/articles/genserver" title="Elixir Concurrent Programming.">Elixir Concurrent Programming. </a></span>
              <span class="date">Jul 09, 2018</span>
            </li>
         <!-- for1 -->
            <li>
              <span class="recent-title"><a href="/articles/apache-beam-python-example" title="Apache Beam. A python example.">Apache Beam. A python example. </a></span>
              <span class="date">May 28, 2018</span>
            </li>
        
      </ol>

      <div class="social">
        <ul>
            <li><a id="mail" href="mailto:bruno.ripa@gmail.com"><span class="foot-link">Contact Me</span></a></li>

            
            <li><a id="twit" href="http://twitter.com/brunoripa" target="_blank"><span class="foot-link">@brunoripa</span></a></li>
            


            
        </ul>
    </div>
    </aside>
    <small>&copy; 2018 Bruno Ripa.</small>
  </footer>

  <!-- If they're out, get some from the cellar -->
  <script>window.jQuery || document.write('<script src="/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
  <script src="/assets/js/retina.min.js"></script>

  <!-- Custom JS -->
  <script src="/assets/js/scripts.js"></script>

  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    
      ga('create', 'UA-XXXXXXXX-X', 'auto');
      ga('send', 'pageview');
  </script>
  </body>
</html>

